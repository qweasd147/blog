{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/spring/spring-oauth2/","result":{"data":{"markdownRemark":{"id":"a52736dc-c82c-5154-86df-1e1adc20bf0d","html":"<p><code class=\"language-text\">OAuth2.0</code>을 <code class=\"language-text\">Spring Security OAuth</code>에서 제공해주는 라이브러리를 사용해 구현 및 필요한 설명 추가.\n기타 <code class=\"language-text\">grand type</code> 방식에 따른 인증 과정(<code class=\"language-text\">access token</code>발급 과정)등은 다른 document 참고</p>\n<h1 id=\"oauth-\" style=\"position:relative;\"><a href=\"#oauth-\" aria-label=\"oauth  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth ?</h1>\n<p>인증 Provider, 외부 API 사이 인증 및 권한 부여 관리하는 일종의 프로토콜</p>\n<p>여기서 설명한 모든 샘플 코드는 <a href=\"https://github.com/qweasd147/springboot-oauth\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">oauth-sample</a> 여기서 확인 가능</p>\n<h1 id=\"oauth-20-플로우-설명\" style=\"position:relative;\"><a href=\"#oauth-20-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%84%A4%EB%AA%85\" aria-label=\"oauth 20 플로우 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth 2.0 플로우 설명</h1>\n<p>특정 리소스 사용까지 전체 플로우(grant type마다 인증 flow는 다르니까 생략)</p>\n<ol>\n<li>특정 사용자가 인증서버를 통해 인증 flow를 거쳐 성공</li>\n<li>토큰 생성 및 TokenStore에 저장</li>\n<li>토큰 발급(반환)</li>\n<li>Resource 서버로 토큰값(access_token)을 요청 api의 헤더에 담아 Resource 서버로 요청</li>\n<li>Resource 제공 서버는 토큰값 validate (JWT를 사용 안하면 인증서버로 토큰 유효성 request를 날립니다)</li>\n<li>Resource 제공</li>\n</ol>\n<h1 id=\"jwt\" style=\"position:relative;\"><a href=\"#jwt\" aria-label=\"jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT</h1>\n<p>JSON Web Token의 줄임말 이지만 OAuth 2.0에서 JWT 도입한다면 추가적으로 이해 해야할 사항이 있습니다.</p>\n<blockquote>\n<p>Resource서버에선 request의 헤더에 담긴 토큰 (access_token)을 validate 할 수 있는 방법이 없습니다. 따라서 매번 인증서버로 토큰의 유효성 검사 api를 요청해야 합니다. 하지만 이는 당연히 많은 시간이 걸릴수 밖에 없습니다. 이러한 문제를 해결하기 위해선 Resource 서버 자체적으로 토큰 유효성 검사를 할 수 있는 방법이 필요하며, 인증서버와 리소스 서버 사이에 약속을 정해놓아야합니다(sign key, pem, jks 사용하여 서로 공유가 필요)</p>\n</blockquote>\n<p><strong>참고</strong>\nresource 서버에서 <code class=\"language-text\">TokenStore</code>를 구현하면 별다른 검증 api없이 validate를 할수 있지만 이는 resource 서버에서 db 정보를 가지고 있을때만 가능합니다.</p>\n<p>JWT를 사용하면 위에서 설명한 Flow가 아래와 같이 바뀝니다.</p>\n<ol>\n<li>특정 사용자가 인증서버를 통해 인증 flow를 거쳐 성공</li>\n<li>토큰 생성 및 발급 <strong>TokenStore에 저장안함</strong></li>\n<li>Resource 서버로 토큰값(access_token)을 요청 api의 헤더에 담아 Resource 서버로 요청</li>\n<li>Resource 제공 서버는 토큰값 자체 유효성 검사</li>\n<li>Resource 제공</li>\n</ol>\n<p>주의할점은 토큰 파싱할 수 있는 정보를 각 resource 서버에 가지고 있으므로 보안상 관리포인트가 늘어나며, 만약 토큰값이 유출되게 된다면 인증서버에서도 차단할 수 있는 방법이 없습니다.</p>\n<p>또한 <code class=\"language-text\">JWT</code>의 특징으로 decode가 빨라야하고 누구나 body값을 encode, decode가 가능합니다. 따라서 토큰변조가 이루어졌는지 체크가 필수적으로 들어갑니다.</p>\n<blockquote>\n<p>JWT의 정보(body값)을 바로 믿는게 아니라 checksum값을 확인하여 변조가 이루어졌는지를 먼저 확인</p>\n</blockquote>\n<h1 id=\"grant-type\" style=\"position:relative;\"><a href=\"#grant-type\" aria-label=\"grant type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Grant Type</h1>\n<p>grant type은 OAuth에서 인증 하는 방식? 방법? 수단 정도로 이해하시면 됩니다. oauth 구현 시 원하는 clint마다 제공해 줄 grant type을 지정해 줄수 있습니다.</p>\n<blockquote>\n<p>앞서 설명한대로 grant type에 따라 인증 flow 가 달라집니다. type에 따른 요구 정보, flow설명 등은 생략합니다. (필요 시 인터넷 참고)</p>\n</blockquote>\n<h3 id=\"1-implict\" style=\"position:relative;\"><a href=\"#1-implict\" aria-label=\"1 implict permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. implict</h3>\n<p>이건 쫌 다른 타입에 비해 관리가 힘듭니다. 문제될껀 없어도 딱히 메리트가 많지 않다고 생각됩니다.</p>\n<p>별도로 <code class=\"language-text\">was</code>를 구축하지 않고 <code class=\"language-text\">spa</code>등의 js앱에 사용 가능하지만, <code class=\"language-text\">refresh token</code>이 발급되지 않습니다.</p>\n<h3 id=\"2-authrozation-code\" style=\"position:relative;\"><a href=\"#2-authrozation-code\" aria-label=\"2 authrozation code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. authrozation code</h3>\n<p>가장 많이 쓰는 방식입니다. 하지만 인증 flow 내에 ui도 함께 구현하여 제공 되어야 합니다. 제공되는 ui를 통해서만 로그인을 진행할 수 있으므로 redirect가 많이 이루어 지는데, 아래와 같은 문제들이 발생합니다.</p>\n<ul>\n<li>인증 서버 로그인 ui로 redirect가 이루어지고, 다시 응답 redirect가 올 때 응답 parameter가 제한됨(커스터 마이징이 힘듦)</li>\n<li>웹에서 비동기 로그인 처리가 불가능</li>\n</ul>\n<p>사실 이 방식은 구현은 쉬운데 사용 측에서 귀찮은 부분이 많습니다.</p>\n<h3 id=\"3-resource-owner-password-credentials-grant-password\" style=\"position:relative;\"><a href=\"#3-resource-owner-password-credentials-grant-password\" aria-label=\"3 resource owner password credentials grant password permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Resource Owner Password Credentials Grant (password)</h3>\n<p>인증서버로 client id, client secret, 계정 ID, 계정 password를 한꺼번에 날려 인증처리를 하는 방식입니다.</p>\n<p>이 방식은 authrozation code와 반대로 따로 제공하는 ui를 사용 안하므로 사용 측에서 구현해야하는 단점이 존재합니다. 하지만 사용 측에서 로그인 전처리, 후처리 등이 쉬운게 장점입니다.</p>\n<p><strong>주의!</strong>\n해당 타입(<code class=\"language-text\">password</code>)은 계정정보가 유출되지 않도록 믿을만한 client에만 지원하도록 제한하고 있습니다.\nex)</p>\n<blockquote>\n<p>본인이 Auth서버와 Client 서버 둘다 만들고 Client서버에서 password 타입으로 인증처리를 하도록 하면 상관없지만(어차피 모든 계정정보를 알고 이쓰니까) 제3의 Client서버에 password 타입을 지원하면 중간에 계정정보가 제3의 서버를 통해 유출되어버릴수가 있습니다.</p>\n</blockquote>\n<h1 id=\"개발-시-선택사항\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%9C-%EC%8B%9C-%EC%84%A0%ED%83%9D%EC%82%AC%ED%95%AD\" aria-label=\"개발 시 선택사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개발 시 선택사항</h1>\n<h2 id=\"token-store\" style=\"position:relative;\"><a href=\"#token-store\" aria-label=\"token store permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Token Store</h2>\n<h3 id=\"1-in-memory-dbh2-등\" style=\"position:relative;\"><a href=\"#1-in-memory-dbh2-%EB%93%B1\" aria-label=\"1 in memory dbh2 등 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. In memory db(h2 등)</h3>\n<p>사실 이건 고민할 여지가 없습니다. 어디까지나 개발용 or 샘플용으로 사용해야 합니다.</p>\n<h3 id=\"2-rdb\" style=\"position:relative;\"><a href=\"#2-rdb\" aria-label=\"2 rdb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. RDB</h3>\n<p>가장 무난합니다. 단점으로는 토큰 생성 시 많은 sql access가 이루어져, 최적화가 필요할 수도 있습니다. 물론 jwt 사용 시 별도로 token 정보를 DB에 저장 하지 않으므로 큰 상관은 없습니다.</p>\n<h3 id=\"3-redis\" style=\"position:relative;\"><a href=\"#3-redis\" aria-label=\"3 redis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Redis</h3>\n<p>개인적으로 토큰 저장소로 redis를 선택하는게 꽤 좋은 방법이라고 생각하였습니다. RDB보단 처리가 빠른 redis가 낫다고 생각했는데 spring security 에 성능적으로 문제가 발생한다고 합니다. 현재는 수정 되었지만 해당 버전을 피하려면 버전 의존관계를 생각하여 도입을 고려해야합니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://youtu.be/mPB2CZiAkKM?t=2975\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://youtu.be/mPB2CZiAkKM?t=2975</a></li>\n<li><a href=\"https://charsyam.wordpress.com/2018/05/11/%EC%9E%85-%EA%B0%9C%EB%B0%9C-spring-security-oauth%EC%9D%98-redistokenstore%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EC%A0%81%ED%95%A9%ED%95%98%EC%A7%80-%EC%95%8A/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://charsyam.wordpress.com/2018/05/11/%EC%9E%85-%EA%B0%9C%EB%B0%9C-spring-security-oauth%EC%9D%98-redistokenstore%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%80-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EC%A0%81%ED%95%A9%ED%95%98%EC%A7%80-%EC%95%8A/</a></li>\n</ul>\n<h2 id=\"jwt-1\" style=\"position:relative;\"><a href=\"#jwt-1\" aria-label=\"jwt 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT</h2>\n<p>앞서 설명한건 JWT가 무엇인지, 왜 사용해야하는지를 설명하였습니다. 하지만 JWT 사용은 필수가 아닌 선택사항이며 JWT를 사용할때와 안할때 access token 인증 case는 아래와 같습니다.</p>\n<h3 id=\"1-jwt-사용할-시\" style=\"position:relative;\"><a href=\"#1-jwt-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%8B%9C\" aria-label=\"1 jwt 사용할 시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. JWT 사용할 시</h3>\n<ol>\n<li>sign key를 지정해서 auth 서버와 모든 resource 서버가 공유한다.</li>\n<li>공개키 방식으로 pem 파일(JKS)을 생성하여 auth 서버와 모든 resource 서버에 각각 셋팅한다.</li>\n</ol>\n<h3 id=\"2-jwt-사용-안할-시\" style=\"position:relative;\"><a href=\"#2-jwt-%EC%82%AC%EC%9A%A9-%EC%95%88%ED%95%A0-%EC%8B%9C\" aria-label=\"2 jwt 사용 안할 시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. JWT 사용 안할 시</h3>\n<ol>\n<li>auth 서버로 access token값을 담아, validate api를 요청하여 토큰값을 검증한다(default)</li>\n<li>token store를 구현하여 자체적으로 token store에서 유효한 값이 존재하는지 검증한다</li>\n</ol>","fields":{"slug":"/posts/spring/spring-oauth2/","tagSlugs":["/tag/spring/","/tag/oauth/","/tag/oauth2/","/tag/auth/"]},"frontmatter":{"date":"2020-04-27T01:07:59.877Z","description":"OAuth2 + Spring boot를 사용하여 인증 Provider 제작 및 고려 사항","tags":["spring","oauth","oauth2","auth"],"title":"OAuth2 with spring boot","socialImage":null}}},"pageContext":{"slug":"/posts/spring/spring-oauth2/"}},"staticQueryHashes":["113262799","1828819329","251939775","401334301"]}