{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/spring/spring-spring-cloud/","result":{"data":{"markdownRemark":{"id":"75cec594-124e-57ea-8e65-f1c06a1d2ec7","html":"<p>여기서 설명할 내용 및 샘플은 <a href=\"https://github.com/qweasd147/spring-cloud\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spring-cloud 샘플</a> 여기서 확인 가능</p>\n<p>샘플을 실행시키기 위해 필요한거</p>\n<ul>\n<li>git</li>\n<li>docker</li>\n<li>docker compose</li>\n</ul>\n<p>실행 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ git clone https://github.com/qweasd147/spring-cloud.git\n$ ls ./spring-cloud\n$ docker-compose up</code></pre></div>\n<h1 id=\"1-msa\" style=\"position:relative;\"><a href=\"#1-msa\" aria-label=\"1 msa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. MSA</h1>\n<p>각각의 용도에 맞게 하나의 큰 어플리케이션이 아닌, 여러개의 작은 어플리케이션으로 쪼개어 변경 및 조합을 쉽게 만든 아키텍쳐</p>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<h3 id=\"확장성이-좋다\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-label=\"확장성이 좋다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장성이 좋다</h3>\n<p>하나의 큰 어플리케이션으로 만들었다고 가정하면 특정 구간 병목현상을 발견하여 어플리케이션을 이중화 하면 많은 리소스를 사용하게 된다. 하지만 여러 어플리케이션으로 나눈 상태에서 특정 어플리케이션만 인스턴스를 늘리는 작업은 상대적으로 적은 리소스만 필요하게 된다.</p>\n<h3 id=\"신기술-적용이-좋다\" style=\"position:relative;\"><a href=\"#%EC%8B%A0%EA%B8%B0%EC%88%A0-%EC%A0%81%EC%9A%A9%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-label=\"신기술 적용이 좋다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>신기술 적용이 좋다</h3>\n<p>기존 레거시 프로그램을 만지다 보면 괜찮다고 생각되는 패턴, 라이브러리 등을 적용을 하고 싶어도 전혀 예상하지 못한곳에 악영양을 줄 수가 있어 고민하게 된다.\n이럴때 차라리 여러개의 작은 어플리케이션 형태라면 이러한 부분을 검토하는 시간도 빠르고, 기존 레거시와 일관성 때문에 생길 수 있는 문제들을 고려하지 않아도 된다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<h3 id=\"성능\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-label=\"성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능</h3>\n<p>MSA는 성능까진 크게 고려하지 않는다. 물론 어느정도 고려 대상이긴 하지만 <code class=\"language-text\">Monolithic Architecture</code>보단 느려질 가능성이 높다.</p>\n<h3 id=\"transaction-처리\" style=\"position:relative;\"><a href=\"#transaction-%EC%B2%98%EB%A6%AC\" aria-label=\"transaction 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Transaction 처리</h3>\n<p>트랜잭션이 보장되어야 하는 작업의 경우, 여러 어플리케이션을 걸쳐 요청한 request를 다시 되돌리기는 힘들다. 이런건 전략적으로 잘 구성해놔야 하는데(<code class=\"language-text\">보상 트랜잭션</code> 등) 이러한 요소 자체가 많은 리스크를 가질수 밖에 없다.</p>\n<h1 id=\"2-spring-cloud\" style=\"position:relative;\"><a href=\"#2-spring-cloud\" aria-label=\"2 spring cloud permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Spring Cloud</h1>\n<p><code class=\"language-text\">Spring Cloud</code>는 이런 MSA 환경에서 각 서비스 간의 통신과 공통 부분 등을 쉽게 구축 및 운영을 도와주는 도구이다. 자주 쓰는 도구로는 아래와 같은 것들이 있다.</p>\n<ol>\n<li>Zuul (API Gateway)</li>\n<li>Eureka (Discovery Server)</li>\n<li>Ribbon (L7 Load Balancing)</li>\n<li>Hystrix (Circuit Breaker)</li>\n<li>Config Server</li>\n<li>Spring Cloud Bus(notify configuration)</li>\n</ol>\n<h2 id=\"21-zuul-api-gateway\" style=\"position:relative;\"><a href=\"#21-zuul-api-gateway\" aria-label=\"21 zuul api gateway permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 Zuul (API Gateway)</h2>\n<p>AWS의 <code class=\"language-text\">API Gateway</code>를 사용 해봤다면 바로 그 용도를 짐작 할 수가 있다. <code class=\"language-text\">entry point</code>로 지정하여 request를 분석하여 특정 어플리케이션으로 라우팅이 가능하고(웹서버의 <code class=\"language-text\">reverse proxy</code>), 인증 기능을 추가 해 줄 수가 있다. 또한 <code class=\"language-text\">AWS API Gateway</code> 이러한 기능이 있는지 모르겠는데 아래와 같이 <code class=\"language-text\">stripPrefix</code>옵션을 주면 <code class=\"language-text\">path</code>값은 대상 어플리케이션에서 제외 하고 보내주는 기능이 있는데 이 기능이 은근 유용할때가 많다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">zuul:\n  routes:\n    auth:\n      path: /auth/**\n      serviceId: auth\n      stripPrefix: true\n      url: http://localhost:8082</code></pre></div>\n<p>예를 들어 위의 설정 처럼 걸어놓으면 클라이언트가 <code class=\"language-text\">https://domain/auth/find/me</code>로 요청을 하면 <code class=\"language-text\">auth</code> 어플리케이션(<code class=\"language-text\">serviceId</code>)의 <code class=\"language-text\">https://localhost:8082/find/me</code>로 연결시켜준다. 물론 <code class=\"language-text\">false</code>면 요청 url 그대로 포워딩 해준다.</p>\n<p>또한 이러한 기능들을 추가로 커스터마이징 할 수 있어 자바 개발자는 정말 친숙하게 사용할 수가 있다.</p>\n<p>(<code class=\"language-text\">AWS</code>의 <code class=\"language-text\">API Gateway</code>가 좋은 점은 생략!)</p>\n<p>한가지 아쉬운 점은 현재 최신 버전 <code class=\"language-text\">spring-cloud-starter-netflix-zuul</code>을 쓰면 기본 <code class=\"language-text\">WAS</code>로 <code class=\"language-text\">Tomcat</code>을 사용하고 있다. 아무래도 <code class=\"language-text\">API Gateway</code>는 성능적으로 민감 할 수가 있어서 <code class=\"language-text\">Tomcat</code> 보다는 그래도 <code class=\"language-text\">Netty</code>(<code class=\"language-text\">undertow</code>)를 쓰는게 어떨까 싶다.</p>\n<p><code class=\"language-text\">Spring cloud Zuul</code>의 연관 모듈인 <code class=\"language-text\">zuul core</code>라는 녀석이 있는데 이게 <code class=\"language-text\">1.x</code> 버전에선 <code class=\"language-text\">Tomcat</code>을 쓰고, <code class=\"language-text\">2.x</code> 버전에선 <code class=\"language-text\">Undertow</code>를 쓰도록 바뀌어서 WAS를 <code class=\"language-text\">Undertow</code>로 바꾸고 싶으면 <code class=\"language-text\">zuul core</code> 버전을 바꾸던가 아니면 <code class=\"language-text\">Tomcat</code>을 제외 시키고 <code class=\"language-text\">Undertow</code>를 추가하던가 선택하면 된다.</p>\n<h2 id=\"22-eureka-discovery-server\" style=\"position:relative;\"><a href=\"#22-eureka-discovery-server\" aria-label=\"22 eureka discovery server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 Eureka (Discovery Server)</h2>\n<p>라이브 환경에선 어느정도 트래픽이 많으면 서버 이중화는 흔한 일이다. 단순 서버 인스턴스를 늘리고 해당 서버를 사용하는 다른 서버에 인스턴스 정보를 넘겨주고, 사용하는 쪽에서 적당히 라운드 로빈(로드벨런싱) 해주면 부하 분산을 위한 서버 다중화 작업은 끝나게 된다. 하지만 말은 쉽게 했지만 이러한 작업은 고려할께 많고 각 서버마다 인스턴스가 늘어가면서 모니터링 및 관리가 힘들어 질 수 밖에 없다. 이러한 귀찮은 작업을 Spring Cloud에서 <code class=\"language-text\">Discovery Server</code>역할을 담당하는 Eureka가 하게 된다. 유레카 서버를 올리고 다른 어플리케이션(<code class=\"language-text\">Eureka Client</code>가 된다)에 Eureka 정보를 넣어주면 어플리케이션이 실행 되면서 Eureka로 어플리케이션 정보 및 상태를 넘겨준다. 이런식으로 모인 각 어플리케이션의 인스턴스 정보를 필요한 어플리케이션에 각각 넣어주고(IP 정보 포함) 종료되면 다시 인스턴스 정보를 갱신한다(기본 적으로 30초 마다 인스턴스에 Ping을 날려 상태 점검도 한다).</p>\n<p>하지만 이번 공부하면서 유레카는 쓰지 않았다. 이유는 딱히 메리트를 못느껴서 그런데 유레카의 역할은 <code class=\"language-text\">Scale in/out</code>시 인스턴스의 정보, 상태를 모니터링 및 관리를 하는데 내가 <code class=\"language-text\">Spring Cloud</code>를 사용하게 된다면 최종적으로 <code class=\"language-text\">Docker</code> + <code class=\"language-text\">Spring Cloud</code> 조합으로 사용할 것이다.</p>\n<p>근데 Docker 생태계(<code class=\"language-text\">Docker Swarm</code>, <code class=\"language-text\">Kubernates</code>) 중엔 이러한 역할을 하는 얘들이 이미 있는데 구지 필요할까 의문이 들었고, 그렇다고 <code class=\"language-text\">Docker</code>를 포기하기엔 잃는게 더 많을꺼라 판단 하였다. <code class=\"language-text\">Docker Swarm</code>이나 <code class=\"language-text\">Kubernates</code>를 사용안하고 순수 <code class=\"language-text\">Docker</code>만 사용한다면 사용하는것도 괜찮을꺼 같긴하다(기술은 필요에 맞춰 도입하면 된다!).</p>\n<p>또한 <code class=\"language-text\">Eureka client</code>들, 그니까 다른 서버들은 Eureka 관련 Library에 종속성이 생기게 된다. 만약 다른 어플리케이션을 <code class=\"language-text\">Node.js</code>나 <code class=\"language-text\">Django</code>같은 걸로 만들었을 경우 <code class=\"language-text\">Eureka client</code>로 등록 하려면 외부 라이브러리를 사용해야 하지만 이러한 라이브러리를 제공해주지 않으면 어떻게 해야할지 감도 안잡힌다. 물론 방법이 있을 수도 있지만 그런거 하나하나 알아보는데 시간을 사용하니, 그냥 안쓰고 <code class=\"language-text\">Docker</code> 쓸꺼 같다.</p>\n<h2 id=\"23-ribbon-l7-load-balancing\" style=\"position:relative;\"><a href=\"#23-ribbon-l7-load-balancing\" aria-label=\"23 ribbon l7 load balancing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 Ribbon (L7 Load Balancing)</h2>\n<blockquote>\n<p><code class=\"language-text\">Load Balancer</code>는 대표적으로 2가지 종류가 있는데 <code class=\"language-text\">L4 Switch</code>, <code class=\"language-text\">L7 Switch</code> 2 종류가 있다. L4는 <code class=\"language-text\">OSI 7Layer</code>에서 L4 계층, 쉽게 말하면 네트워크 장비로 로드 벨런싱을 하는 것이고, L7은 <code class=\"language-text\">Application</code> 계층으로 로드 벨런싱을 하는 것을 말한다. <code class=\"language-text\">L4 Switch</code>는 가격이 엄청나게 비싸므로 돈없으면 사용하지도 못하거나 아니면 AWS의 <code class=\"language-text\">NLB</code>를 알아보면 되고, 여건이 안되면 결국에 사용해야 할 것은 <code class=\"language-text\">L7 Load Balancer</code> 이다</p>\n</blockquote>\n<p>우선 <code class=\"language-text\">Load Balancing</code>을 하고 싶으면 최소 2개 이상의 서버 인스턴스가 필요하고, 해당 인스턴스의 물리적 접근 주소(IP, Port 번호)를 <code class=\"language-text\">Load Balancer</code>에 제공해야 한다. 이때 <code class=\"language-text\">Eureka</code>와 궁합이 잘 맞는데 위에서 잠깐 설명 하였지만 Eureka는 필요한 곳에 물리적인 서버 목록을 제공해 준다.</p>\n<h4 id=\"ribbon\" style=\"position:relative;\"><a href=\"#ribbon\" aria-label=\"ribbon permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ribbon</h4>\n<p>Load balancing 관련 작업을 관리한다. <code class=\"language-text\">timeout</code>, <code class=\"language-text\">retry 정책</code>등을 설정 가능하고 필요한 서버 목록은 직접 물리적 주소를 적는 방법도 있으나, 그렇게 하면 탄력적으로 주소값을 확보 할 수 없으므로 <code class=\"language-text\">Eureka</code>한테 필요한 서버 목록 리스트를 요청하도록 셋팅도 가능하다.</p>\n<h4 id=\"eureka\" style=\"position:relative;\"><a href=\"#eureka\" aria-label=\"eureka permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Eureka</h4>\n<p>주기적으로 헬스 체크를 하여, 현재 활성화 된 서버 인스턴스 목록을 Ribbon에 제공해준다.</p>\n<hr>\n<p>Ribbon이 좋긴 하지만 이번 공부엔 절반 정도의 기능만 사용하였다. <code class=\"language-text\">timeout</code>, <code class=\"language-text\">retry</code> 정책 정도만 사용하고 <code class=\"language-text\">Load Balancing</code>작업은 Ribbon이 아닌 docker를 통해서 할 생각이기 때문이다.</p>\n<h2 id=\"24-hystrix-circuit-breaker\" style=\"position:relative;\"><a href=\"#24-hystrix-circuit-breaker\" aria-label=\"24 hystrix circuit breaker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 Hystrix (Circuit Breaker)</h2>\n<p><code class=\"language-text\">Hystix</code>에서 제공해주는 기능은 대표적으로 <code class=\"language-text\">Request Caching</code>, <code class=\"language-text\">장애 전파 방지</code> 기능이 있다. 이 중 <code class=\"language-text\">Request Caching</code>은 딱히 어려운 내용도 아니고 다른 쪽에서도 많이 사용 할 수 있으니까 Pass하고 추가로 기능은 아니지만 관리 정책으로 request 격리 방식을 지정 할 수가 있다.</p>\n<h3 id=\"circuit-breaker요청-차단\" style=\"position:relative;\"><a href=\"#circuit-breaker%EC%9A%94%EC%B2%AD-%EC%B0%A8%EB%8B%A8\" aria-label=\"circuit breaker요청 차단 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Circuit Breaker(요청 차단)</h3>\n<p><code class=\"language-text\">Circuit Breaker</code>는 간단히 말해 특정 조건이 만족하면 요청 자체를 실행하지 않고 내부적으로 <code class=\"language-text\">fallback</code>을 실행하는 방식이다.</p>\n<p><code class=\"language-text\">Circuit Breaker</code>를 사용하는 이유는 만약 특정 서비스 <code class=\"language-text\">A</code> -> <code class=\"language-text\">B</code> -> <code class=\"language-text\">C</code> 순서로 호출한다고 가정 할 때, <code class=\"language-text\">C</code>측에서 처리량이 적거나 DB에 LOCK이 걸려 무한 대기가 발생 할 경우 <code class=\"language-text\">A</code>, <code class=\"language-text\">B</code>, <code class=\"language-text\">C</code> 모두가 무한 대기가 걸리게 된다. 물론 <code class=\"language-text\">Timeout</code>이 걸려 있을테니 진짜 무한대기는 아니겠지만 적어도 <code class=\"language-text\">A</code>, <code class=\"language-text\">B</code>만큼은 빠른 응답, 또 <code class=\"language-text\">C</code>한테 불필요한 트래픽(어차피 실패할꺼)을 줄이기 위해 <code class=\"language-text\">B</code>는 <code class=\"language-text\">C</code>를 호출하는 대신 자체 <code class=\"language-text\">fallback</code>을 실행 시킨다(<code class=\"language-text\">Circuit Breaker open</code> 상태) 그러다가 일정 시간이 지나면 다시 확인 해보고 이상이 없으면 다시 정상적으로 처리한다(<code class=\"language-text\">Circuit Breaker close</code> 상태).</p>\n<h3 id=\"isolation-방법\" style=\"position:relative;\"><a href=\"#isolation-%EB%B0%A9%EB%B2%95\" aria-label=\"isolation 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Isolation 방법</h3>\n<p><code class=\"language-text\">Micro Service</code>는 하나의 어플리케이션에서 모든 일을 하는게 아닌, 필요에 따라 내부적으로 다른 어플리케이션을 호출하여 처리하는 방식이 많다. 이때 중요한건 다른 서비스를 호출해야 한다는 점인데 이때 호출을 관리하는 방법은 <code class=\"language-text\">Thread Pools</code> 방식과 <code class=\"language-text\">Semaphore</code> 방식 두가지를 사용한다.</p>\n<p>참고사항으로 <code class=\"language-text\">Thread Pools</code> &#x26; <code class=\"language-text\">Semaphore</code> 개념은 <code class=\"language-text\">Spring cloud</code>에서 시작한 개념은 아니니까 다른곳에서 검색해보면(…) 더 자세한 정보를 얻을 수 있다.</p>\n<h4 id=\"semaphore\" style=\"position:relative;\"><a href=\"#semaphore\" aria-label=\"semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Semaphore</h4>\n<p>사실 <code class=\"language-text\">Semaphore</code>는 격리라고 보기에는 애매하다. 외부 어플리케이션 호출을 별도의 <code class=\"language-text\">Thread</code>를 할당 받는게 아닌 현재 사용중인 <code class=\"language-text\">Thread</code>를 그대로 사용하는 방식이다. 단순 동시 호출(<code class=\"language-text\">Concurrency</code>) 개수를 지정해 놨다가 사용하는 방식이라 장점은 <code class=\"language-text\">Thread Pools</code> 방식에 비해 빠르다는 점이 있지만 의미있는 값은 아니고, 단점으로는 별도의 <code class=\"language-text\">Thread</code>를 사용하지 않아 지연문제 발생 시 다른곳에 영향을 미칠수 있다는 점이다(이 부분은 추가로 확인 해봐야함).</p>\n<h4 id=\"thread-pool\" style=\"position:relative;\"><a href=\"#thread-pool\" aria-label=\"thread pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread-Pool</h4>\n<p>Hystrix에서 관리하는 별도의 <code class=\"language-text\">Thread Pool</code>을 사용해서 외부 어플리케이션을 호출하는 방식이다. 따라서 동시 호출 개수는 <code class=\"language-text\">Thread Pool</code>에서 확보한 Thread 만큼 가능하고, 장점으로는 별도의 <code class=\"language-text\">Thread</code>로 사용하니 외부 시스템과 완전히 격리된다는 점이다. 단점으로는 별도의 <code class=\"language-text\">Thread Pool</code>을 관리하는데 오는 리소스, 오버헤드 등이 있지만 이러한 비용은 크게 신경쓰지 않고 거의 모든 케이스에서 <code class=\"language-text\">Thread Pool</code> 방식을 권장하고 있다.</p>\n<h2 id=\"25-config-server\" style=\"position:relative;\"><a href=\"#25-config-server\" aria-label=\"25 config server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.5 Config Server</h2>\n<p>하나의 어플리케이션만 사용할때는 잘 느껴지지 않지만 여러 어플리케이션으로 나누어 관리하다 보면 프로퍼티 설정값들 관리가 힘들어 질 때가 있다. 비슷한 설정값들을 다른 어플리케이션에 각각 관리되어야 하고, 한 두개만 바꾸고 싶어도 다 수정하고 빌드 배포까지 해야한다는 점이 귀찮은 요소이다. 물론 프로퍼티 파일은 컴파일 대상도 아닌데 무슨 다 다시 빌드하냐고 생각 할 수 있지만 역시 기준은 <code class=\"language-text\">docker</code> 환경이기 때문이기도 하고 빌드 배포 시스템이 자동으로 갖추어져 있으면 결국 다시 빌드 배포하게 된다.</p>\n<p><code class=\"language-text\">Config Server</code>는 이러한 설정 값들을 한 곳에서 관리하고 있다가 필요한 어플리케이션에서 요청이 오면 값을 넘겨주는 형태로 제공하는 서버이다. <code class=\"language-text\">Application Name</code>, <code class=\"language-text\">Profile</code> 조합으로 값을 요청 할 수가 있고 공통적으로 제공해주는 값도 일괄적으로 관리 할 수가 있어 편하다. 문제는 특정 비밀번호 등의 예민한 값들 관리가 귀찮다는 건데, <code class=\"language-text\">Vault</code>같은 걸 써야 되지만 이게 꽤 귀찮은게 많고 결국 파일 시스템으로 관리되는데 차라리 <code class=\"language-text\">Docker</code>쪽에서 비슷한 역할을 하는것을 찾아서 쓰는게 어떨까 싶다(<code class=\"language-text\">Kubernates Secret</code> 등).</p>\n<h2 id=\"26-spring-cloud-busnotify-configuration\" style=\"position:relative;\"><a href=\"#26-spring-cloud-busnotify-configuration\" aria-label=\"26 spring cloud busnotify configuration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.6 Spring Cloud Bus(notify configuration)</h2>\n<p><code class=\"language-text\">Config Server</code>를 사용하여 설정 파일과 소스파일을 완전히 분리해서 관리하다 설정 파일을 바꾸고 어플리케이션에 적용하려면 어플리케이션을 다시 시작하거나 아니면 인스턴스에서 특정 api를 호출하여 최신 설정값을 셋팅하도록 유도하는 수 밖에 없다. 인스턴스가 한두개 있다는 보장도 없고 외부에서 호출하기도 까다로워 불편한 점이 있는데 <code class=\"language-text\">Spring Cloud Bus</code>는 설정값이 바뀌면 <code class=\"language-text\">Message Queue</code>를 통해 알려주고, 해당 <code class=\"language-text\">Message Queue</code>에 연결된 인스턴스는 서버 재시작 없이 설정값을 갱신하게 된다.</p>\n<p>좋은것 같지만 아무래도 처리중인 데이터가 존재할 수도 있는데 설정값을 갱신한다는건 부담이 있는거 같아 이것 역시 관련 이슈가 있는지 검토를 해보고 적용여부를 다시 검토 해보는게 좋을것 같다.</p>","fields":{"slug":"/posts/spring/spring-spring-cloud/","tagSlugs":["/tag/spring/","/tag/cloud/","/tag/msa/"]},"frontmatter":{"date":"2020-09-03T00:55:55.498Z","description":"MSA 환경에서 여러 어플리케이션을 효과적으로 개발 및 관리","tags":["spring","cloud","msa"],"title":"Spring Cloud - 기본 설명","socialImage":null}}},"pageContext":{"slug":"/posts/spring/spring-spring-cloud/"}},"staticQueryHashes":["251939775","2839666046","2891173899","401334301"]}