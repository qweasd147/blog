{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/etc/etc-dynamodb/","result":{"data":{"markdownRemark":{"id":"69c8a34e-641c-5c9b-bf39-7feb6c439f44","html":"<h1 id=\"dynamodb\" style=\"position:relative;\"><a href=\"#dynamodb\" aria-label=\"dynamodb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamodb</h1>\n<p>DynamoDB 공부하면서 배운 기본 사항 정리.</p>\n<h2 id=\"1-기본은-key--value-형태의-db\" style=\"position:relative;\"><a href=\"#1-%EA%B8%B0%EB%B3%B8%EC%9D%80-key--value-%ED%98%95%ED%83%9C%EC%9D%98-db\" aria-label=\"1 기본은 key  value 형태의 db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 기본은 Key &#x26; Value 형태의 DB</h2>\n<p>기본은 key value 형태의 <code class=\"language-text\">nosql</code> 형태의 DB 이다.</p>\n<p>또한 데이터의 유일한 식별키인 <code class=\"language-text\">Primary key</code>가 <strong>반드시</strong> 존재한다.</p>\n<h2 id=\"2-primary-key-partition-key-range-key\" style=\"position:relative;\"><a href=\"#2-primary-key-partition-key-range-key\" aria-label=\"2 primary key partition key range key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Primary key, Partition key, Range key</h2>\n<h3 id=\"21-primary-key\" style=\"position:relative;\"><a href=\"#21-primary-key\" aria-label=\"21 primary key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 Primary key</h3>\n<p>딱 부러지게 내가 지정한다기 보다는 유도를 하는 느낌. 기본적으로 테이블을 만들 시 <code class=\"language-text\">Partition Key</code>는 필수로 지정을 해야하는데 <code class=\"language-text\">Partition Key</code>만 지정하게 되면 일단 <code class=\"language-text\">Primary key</code>는 <code class=\"language-text\">Partition Key</code>가 된다. <code class=\"language-text\">Range key</code>도 함께 설정을 하게 된다면 <code class=\"language-text\">Primary key</code>는 <code class=\"language-text\">Partition key</code> + <code class=\"language-text\">Range key</code>를 조합한 혼합키 형태가 된다.</p>\n<h3 id=\"22-partition-key\" style=\"position:relative;\"><a href=\"#22-partition-key\" aria-label=\"22 partition key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 Partition key</h3>\n<p><code class=\"language-text\">Range key</code>를 지정하지 않았다면 식별키(<code class=\"language-text\">PK</code>)가 된다. 하지만 식별키라고 그대로 이해하기 보단 이름 그대로 해당 Partition에 key값이라고 이해해야 한다. 만약 <code class=\"language-text\">GSI</code>를 따로 지정하지 않았다면 하나의 파티션(<code class=\"language-text\">Table</code>)안에 있는 key값이라 생각하고 <code class=\"language-text\">GSI</code>를 지정하게 된다면 여러 파티션(<code class=\"language-text\">Table</code>)안에 각각의  key 값들이라고 생각하면 된다. 이해가 어렵다면 우선 <code class=\"language-text\">Secondary Index</code>(<code class=\"language-text\">LSI</code>, <code class=\"language-text\">GSI</code>) 먼저 보는걸 추천.</p>\n<h3 id=\"23-range-key\" style=\"position:relative;\"><a href=\"#23-range-key\" aria-label=\"23 range key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 Range key</h3>\n<p>DynamoDB는 별다른 설정을 안했다면 데이터를 추출 시 정렬이 불가능하다. 정렬된 형태로 값을 원할 시 <code class=\"language-text\">Range Key</code>또는 <code class=\"language-text\">범위 키</code>라고도 하는 옵션을 설정하면 그때서야 정렬이 가능하다. 하지만 <code class=\"language-text\">2.1</code>에서 설명한 대로 <code class=\"language-text\">Range key</code>를 설정하게 되면 하나의 레코드의 고유한 <code class=\"language-text\">Primary key</code>(RDB의 pk)는 <code class=\"language-text\">Partition Key</code> + <code class=\"language-text\">Range Key</code>가 되므로 이점을 주의해야 한다.</p>\n<h2 id=\"3-query-scan\" style=\"position:relative;\"><a href=\"#3-query-scan\" aria-label=\"3 query scan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Query, Scan</h2>\n<h3 id=\"31-scan\" style=\"position:relative;\"><a href=\"#31-scan\" aria-label=\"31 scan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 scan</h3>\n<p>scan은 테이블의 모든 데이터를 찾는 형태고 지정된 표현식으로 필터링 하여 값을 가져올 수가 있다. 구지 <code class=\"language-text\">Primary key</code>값을 조건으로 검색을 안해도 값을 구할 수가 있다. 이때 가져오는 값은 정렬은 불가능한걸로 알고 있다.</p>\n<h3 id=\"32-query\" style=\"position:relative;\"><a href=\"#32-query\" aria-label=\"32 query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 query</h3>\n<p>주어진 범위(partition) 내에서 해당 데이터만 찾기 때문에 검색이 빠르다. 인덱스를 지정해서 해당 범위만 찾게 할 수도 있어서 여러모로 유용하지만 단점으로는 당연히 <code class=\"language-text\">주어진 범위</code>값을 줘야하는데 이 값이 <code class=\"language-text\">Partition Key</code>이다. 만약 <code class=\"language-text\">Partition key</code>값을 일반 RDB의 <code class=\"language-text\">PK</code>값(고유한 값)을 사용한다면 꽤나 난감한 상황이 발생된다. 조건에 맞는 데이터를 검색하는데 <code class=\"language-text\">PK</code>를 알아야하는 상황이 발생한다.</p>\n<h2 id=\"4-lsi-gsi\" style=\"position:relative;\"><a href=\"#4-lsi-gsi\" aria-label=\"4 lsi gsi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. LSI, GSI</h2>\n<h3 id=\"41-lsi\" style=\"position:relative;\"><a href=\"#41-lsi\" aria-label=\"41 lsi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1 LSI</h3>\n<p>기본 테이블의 <code class=\"language-text\">Partition Key</code>값을 유지하고, <code class=\"language-text\">Range Key</code>만 바꿔서 인덱싱을 하는 형태. 읽기, 쓰기 비용이 추가로 발생하진 않지만 활용도 면은 썩 좋진 않은거 같다.</p>\n<h3 id=\"42-gsi\" style=\"position:relative;\"><a href=\"#42-gsi\" aria-label=\"42 gsi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2 GSI</h3>\n<p>테이블 안에 테이블을 만든다고 생각하는게 편하다. 새롭게 <code class=\"language-text\">Partition key</code>를 지정하고, 옵션으로 <code class=\"language-text\">Range Key</code> 지정이 가능하다. 테이블 안에 테이블을 만든다고 했는데 진짜로 내부적으로 그렇게 사용해서 GSI를 지정하면 쓰기 비용이 훨씬 증가한다. 데이터를 삽입할 때 ‘테이블 안에 테이블’에 어떤값을 저장할지 지정해 줄 수 있다. partition &#x26; range key만 저장(<code class=\"language-text\">KEYS_ONLY</code>)하거나 특정 attribute만 저장(INCLUDE), 아니면 저장되는 모든 데이터를 지정(<code class=\"language-text\">ALL</code>)할 수도 있는데 물론 저장하는 데이터를 많이 지정할 수록 쓰기비용이 더욱 늘어나고 이러한 옵션을 <code class=\"language-text\">Projection</code> 또는 <code class=\"language-text\">Projection type</code>이라고 한다.</p>\n<p>장점으로는 <code class=\"language-text\">Query</code>를 요청 시 <code class=\"language-text\">Partition key</code>값을 필수로 요구하는데 테이블의 공통된 값 아무거나 <code class=\"language-text\">Partition Key</code>로 묶어 <code class=\"language-text\">GSI</code>를 지정하면 내가 지정한 <code class=\"language-text\">Range Key</code>값에 따라 정렬이 보장된 조회할 수가 있다(쿼리 요청 시 <code class=\"language-text\">GSI</code> index name을 넘겨주기만 하면 된다.)</p>","fields":{"slug":"/posts/etc/etc-dynamodb/","tagSlugs":["/tag/aws/","/tag/nosql/","/tag/db/"]},"frontmatter":{"date":"2016-02-07T22:40:32.169Z","description":"aws의 No SQL 완전관리형 DB","tags":["aws","nosql","db"],"title":"Dynamo DB","socialImage":null}}},"pageContext":{"slug":"/posts/etc/etc-dynamodb/"}}}