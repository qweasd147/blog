{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/etc/etc-db-optimizer/","result":{"data":{"markdownRemark":{"id":"c40620a0-7997-5f69-bc09-d238d2b8a85a","html":"<h3 id=\"사전지식-1-옵티마이저\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D-1-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80\" aria-label=\"사전지식 1 옵티마이저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사전지식 1. 옵티마이저</h3>\n<p>rdb는 sql질의문을 요청하면 해당 쿼리를 분석하여 최적의 실행 방법을 결정(어딜 어떻게 먼저 조회하고, 어떤 인덱스를 쓰고, 인덱스 타입은 이렇게 된다. -> 실행계획) 한 후, 그거 대로 실행한다. 그래서 적당히만 짜도 옵티마이저가 알아서 잘 분석하고 실행한다. 물론 최적의 인덱스 퍼포먼스를 보여줘야 한다면 그건 쫌 다른 이야기가 되버리는데, index랑 옵티마이저만 믿고 있다간 <code class=\"language-text\">full scan</code> or <code class=\"language-text\">full index</code> 이런거 걸려버리면 성능적으로 엄청난 문제가 생기긴 한다. 아무튼 요지는 테이블 순서나 <code class=\"language-text\">where</code> 조건절 순서 등에 관해선 옵티마이저 믿고 꽤나 자유롭게 짜도 별 상관이 없다.</p>\n<h3 id=\"사전지식-2-mysql-옵티마이저는-비용-기반으로-책정됨\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D-2-mysql-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80%EB%8A%94-%EB%B9%84%EC%9A%A9-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%B1%85%EC%A0%95%EB%90%A8\" aria-label=\"사전지식 2 mysql 옵티마이저는 비용 기반으로 책정됨 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사전지식 2. mysql 옵티마이저는 비용 기반으로 책정됨</h3>\n<p>옵티마이저는 규칙 기반 옵티마이저(rule based optimizer. 줄여서 rbo), 비용기반 옵티마이저(cost based optimizer. 줄여서 cbo) 2가지 종류가 있는데, 줄여서 설명하면 rbo는 그냥 룰이 무조건 정해져서 별다른 리소스 상태 같은건 무시하고 그 조건 내에서만 실행계획을 새워서 실행하고 cbo는 먼저 각을 재고(비용,리소스 계산. 어떻게 검색해야 더 좋을까, 드라이빙 테이블은 어떤걸 지정할까 등등) 실행계획을 새운다.</p>\n<p>mysql을 포함해서 너무 오래된 버전이 아니라면 사실상 다 cbo를 쓰는데 방금 말한거 처럼 각 재고 실행을 한다는 점. 그니까 <strong>똑같은 쿼리문을 날려도 경우에 따라 실행 계획이 달라질 수 있다는 점이다.</strong></p>\n<hr>\n<p>이번 post에선 옵티마이저가 실행계획을 잘못 만드는 케이스를 소개&#x26;분석하는게 목적이다.</p>\n<p>테스트용 테이블. 미리 말하면 이전 샘플용으로 만들어져 있는 테이블을 테스트용 테이블로 쓰고 있어서 스키마&#x26;관계 정보는 이해 부탁드립니다.\n<img src=\"/blog/media/db/img01.png\" alt=\"img1\"></p>\n<h3 id=\"테이블-설명\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%A4%EB%AA%85\" aria-label=\"테이블 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테이블 설명</h3>\n<ul>\n<li><code class=\"language-text\">article</code> -> 그냥 테이블1. 테스트 환경을 기준으로 10만개 정도 데이터 row 가 있음</li>\n<li><code class=\"language-text\">tag</code> -> article과 연관관계가 있고, fk를 같고있는 주체가 되는 테이블이며 <strong>1대1 관계로 관리 되고 있음.</strong> 15개 정도 데이터 row가 있음</li>\n<li><code class=\"language-text\">tag2</code> -> tag 테이블이랑 다 똑같은데 데이터 row가 딱 1개만 있음</li>\n</ul>\n<h2 id=\"case-1-위와-같은-상황에서-articletag-테이블을-left-join-하면\" style=\"position:relative;\"><a href=\"#case-1-%EC%9C%84%EC%99%80-%EA%B0%99%EC%9D%80-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-articletag-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-left-join-%ED%95%98%EB%A9%B4\" aria-label=\"case 1 위와 같은 상황에서 articletag 테이블을 left join 하면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>case 1. 위와 같은 상황에서 article&#x26;tag 테이블을 left join 하면?</h2>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> article\n<span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> tag <span class=\"token keyword\">on</span> tag<span class=\"token punctuation\">.</span>article_id <span class=\"token operator\">=</span> article<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> article<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">limit</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그냥 정상적인 결과가 나온다. 실행 계획상에서도 전혀 문제가 없고, 실행되는 시간도 내 테스트 환경 기준으로 0.0019초 나온다.</p>\n<p><img src=\"/blog/media/db/img02.png\" alt=\"img2\"></p>\n<h2 id=\"case-2-하지만-여기서-articletag2-테이블을-left-join-하면\" style=\"position:relative;\"><a href=\"#case-2-%ED%95%98%EC%A7%80%EB%A7%8C-%EC%97%AC%EA%B8%B0%EC%84%9C-articletag2-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-left-join-%ED%95%98%EB%A9%B4\" aria-label=\"case 2 하지만 여기서 articletag2 테이블을 left join 하면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>case 2. 하지만 여기서 article&#x26;tag2 테이블을 left join 하면?</h2>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> article\n<span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> tag2 <span class=\"token keyword\">on</span> tag2<span class=\"token punctuation\">.</span>article_id <span class=\"token operator\">=</span> article<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> article<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">limit</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>엄청나게 느려진다. 실행 시간도 0.08초 ~ 0.152초로 대폭 증가한다(이 갭 관련해선 밑에서 설명). 다른 요소는 다 똑같은데 데이터가 많은 테이블을 조인하는건 빠르고 데이터가 적은 테이블을 조인 해서 결과를 얻는 것이 더 느리다는게 일반적으로 생각하면 말이 안된다.</p>\n<p><code class=\"language-text\">mysql 5.7</code> 버전으로 실행 계획을 확인해보면 아래와 같이 나온다\n<img src=\"/blog/media/db/img03.png\" alt=\"img3\"></p>\n<p>이런 결과가 나온건 내가 알기론 먼저 db조인을 할때 만약 테이블에 데이터가 얼마 없다면 옵티마이저가 모든 데이터와 조인 결과를 memory에 다 올려놓고 처리하는걸로 알고 있다. 근데 하필 <code class=\"language-text\">left join</code> 을 하면서 모든데이터를 올려놓다 보니 너무 데이터가 많아서 오히려 더 안좋은 실행계획이 세워지는 것으로 추측하고 있다</p>\n<p>두번째 실행 계획에서 <code class=\"language-text\">using join buffer(BNL)</code> , <code class=\"language-text\">Using temprary; Using filesort</code> 이렇게 뜨는걸 보고 그렇게 추측하였다(row 개수가 적으면 모든 데이터를 불러 온 후, 핸들링 하는거 자체는 맞는 말이다).</p>\n<p>이런 케이스는 일하면서 한번쯤은 만날 수 있는 경우라고 생각되는데 해결 방법으로는</p>\n<ol>\n<li>그냥 조인 안씀(개인적으로 이거 추천)</li>\n<li>가능하면 inner join으로 변경</li>\n<li>hint를 줘서 실행계획을 유도(딱히 추천하지는 않음. 해당 쿼리에 대해 관리비용이 더 들 수도 있다)</li>\n</ol>\n<blockquote>\n<p>개발하면서 RDB라서 별 수 없긴 하지만 join이란건 생각보다 어플리케이션에 많은 문제를 발생시킬 수가 있다(대부분 의존관계 문제이다. 무분별하게 의존관계를 다 때려 넣는 짓은 하면 안된다) 이런 저런 이유로 생각 외로 join 안쓰면 많은 문제를 예방 하는 효과가 있긴하다.</p>\n</blockquote>\n<p>만약 <code class=\"language-text\">inner join</code> 을 하게 되면 위와 같은 문제가 없어지고, 실행계획을 봐도 <code class=\"language-text\">driving table</code> 이 바뀌는거 말곤 딱히 특이한 점은 없다.</p>\n<p>참고 사항으로 <code class=\"language-text\">mysql 5.7</code> 버전에선 <code class=\"language-text\">BNL 조인</code>이 되어버리지만 <code class=\"language-text\">mysql 8.0</code>이면 <code class=\"language-text\">hash join</code>으로 처리 해준다(8.0부터 지원 해주는걸로 알고 있다) 위에서 실행 시간 말할때 0.15초 정도 걸린 환경은 <code class=\"language-text\">mysql 5.7</code> 버전에서 BNL 조인 되면서 나온 속도이고 <code class=\"language-text\">mysql 8.0</code>으로 올리면 hash join 으로 개선되어 0.8초 정도 속도가 나오고 있다. 물론 0.8초도 엄청 느린거고 row 개수에 따라 더욱 느려질 것이므로 피해서 써야하는건 똑같다.</p>\n<p><img src=\"/blog/media/db/img04.png\" alt=\"img4\"></p>\n<blockquote>\n<p>성능 측정 같은 경우엔 컴퓨터 성능에 따라 달라 질 수도 있다.</p>\n</blockquote>\n<hr>\n<p>결론</p>\n<ol>\n<li>옵티마이저는 똑똑하지만 항상 정확한 실행계획을 보장 해주는건 아니다.</li>\n<li>모르겠다 생각 되면 그냥 실행계획 보자.</li>\n</ol>","fields":{"slug":"/posts/etc/etc-db-optimizer/","tagSlugs":["/tag/db/","/tag/mysql/","/tag/optimizer/"]},"frontmatter":{"date":"2021-12-30T13:17:17.507Z","description":"mysql 옵티마이저의 함정 요소. 옵티마이저를 너무 믿으면 안되는 이유","tags":["db","mysql","optimizer"],"title":"Mysql Optimizer","socialImage":null}}},"pageContext":{"slug":"/posts/etc/etc-db-optimizer/"}},"staticQueryHashes":["1828819329","251939775","2839666046","401334301"]}