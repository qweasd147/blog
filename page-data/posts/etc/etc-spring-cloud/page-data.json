{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/etc/etc-spring-cloud/","result":{"data":{"markdownRemark":{"id":"4e8c8f5e-604a-5aae-a7fb-127adeb5ff0b","html":"<p>여기서 설명할 내용 및 샘플은 <a href=\"https://github.com/qweasd147/spring-cloud\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spring-cloud 샘플</a> 여기서 확인 가능</p>\n<p>샘플을 실행시키기 위해 필요한거</p>\n<ul>\n<li>git</li>\n<li>docker</li>\n<li>docker compose</li>\n</ul>\n<p>실행 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ git clone https://github.com/qweasd147/spring-cloud.git\n$ ls ./spring-cloud\n$ docker-compose up</code></pre></div>\n<h1 id=\"1-msa\" style=\"position:relative;\"><a href=\"#1-msa\" aria-label=\"1 msa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. MSA</h1>\n<p>각각의 용도에 맞게 하나의 큰 어플리케이션이 아닌, 여러개의 작은 어플리케이션으로 쪼개어 변경 및 조합을 쉽게 만든 아키텍쳐</p>\n<h2 id=\"장점\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h2>\n<h3 id=\"확장성이-좋다\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-label=\"확장성이 좋다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장성이 좋다</h3>\n<p>하나의 큰 어플리케이션으로 만들었다고 가정하면 특정 구간 병목현상을 발견하여 어플리케이션을 이중화 하면 많은 리소스를 사용하게 된다. 하지만 여러 어플리케이션으로 나눈 상태에서 특정 어플리케이션만 인스턴스를 늘리는 작업은 상대적으로 적은 리소스만 필요하게 된다.</p>\n<h3 id=\"신기술-적용이-좋다\" style=\"position:relative;\"><a href=\"#%EC%8B%A0%EA%B8%B0%EC%88%A0-%EC%A0%81%EC%9A%A9%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-label=\"신기술 적용이 좋다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>신기술 적용이 좋다</h3>\n<p>기존 레거시 프로그램을 만지다 보면 괜찮다고 생각되는 패턴, 라이브러리 등을 적용을 하고 싶어도 전혀 예상하지 못한곳에 악영양을 줄 수가 있어 고민하게 된다.\n이럴때 차라리 여러개의 작은 어플리케이션 형태라면 이러한 부분을 검토하는 시간도 빠르고, 기존 레거시와 일관성 때문에 생길 수 있는 문제들을 고려하지 않아도 된다.</p>\n<h2 id=\"단점\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단점</h2>\n<h3 id=\"성능\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-label=\"성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능</h3>\n<p>MSA는 성능까진 크게 고려하지 않는다. 물론 어느정도 고려 대상이긴 하지만 <code class=\"language-text\">Monolithic Architecture</code>보단 느려질 가능성이 높다.</p>\n<h3 id=\"transaction-처리\" style=\"position:relative;\"><a href=\"#transaction-%EC%B2%98%EB%A6%AC\" aria-label=\"transaction 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Transaction 처리</h3>\n<p>트랜잭션이 보장되어야 하는 작업의 경우, 여러 어플리케이션을 걸쳐 요청한 request를 다시 되돌리기는 힘들다. 이런건 전략적으로 잘 구성해놔야 하는데(<code class=\"language-text\">보상 트랜잭션</code> 등) 이러한 요소 자체가 많은 리스크를 가질수 밖에 없다.</p>\n<h1 id=\"2-spring-cloud\" style=\"position:relative;\"><a href=\"#2-spring-cloud\" aria-label=\"2 spring cloud permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Spring Cloud</h1>\n<p><code class=\"language-text\">Spring Cloud</code>는 이런 MSA 환경에서 각 서비스 간의 통신과 공통 부분 등을 쉽게 구축 및 운영을 도와주는 도구이다. 자주 쓰는 도구로는 아래와 같은 것들이 있다.</p>\n<ol>\n<li>Zuul (API Gateway)</li>\n<li>Eureka (Discovery Server)</li>\n<li>Ribbon (L7 Load Balancing)</li>\n<li>Hystrix (Circuit Breaker)</li>\n<li>Config Server</li>\n<li>Spring Cloud Bus(notify configuration)</li>\n</ol>\n<h2 id=\"21-zuul-api-gateway\" style=\"position:relative;\"><a href=\"#21-zuul-api-gateway\" aria-label=\"21 zuul api gateway permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 Zuul (API Gateway)</h2>\n<p>AWS의 <code class=\"language-text\">API Gateway</code>를 사용 해봤다면 바로 그 용도를 짐작 할 수가 있다. <code class=\"language-text\">entry point</code>로 지정하여 request를 분석하여 특정 어플리케이션으로 라우팅이 가능하고(웹서버의 <code class=\"language-text\">reverse proxy</code>), 인증 기능을 추가 해 줄 수가 있다. 또한 <code class=\"language-text\">AWS API Gateway</code> 이러한 기능이 있는지 모르겠는데 아래와 같이 <code class=\"language-text\">stripPrefix</code>옵션을 주면 <code class=\"language-text\">path</code>값은 대상 어플리케이션에서 제외 하고 보내주는 기능이 있는데 이 기능이 은근 유용할때가 많다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">zuul:\n  routes:\n    auth:\n      path: /auth/**\n      serviceId: auth\n      stripPrefix: true\n      url: http://localhost:8082</code></pre></div>\n<p>예를 들어 위의 설정 처럼 걸어놓으면 클라이언트가 <code class=\"language-text\">https://domain/auth/find/me</code>로 요청을 하면 <code class=\"language-text\">auth</code> 어플리케이션(<code class=\"language-text\">serviceId</code>)의 <code class=\"language-text\">https://localhost:8082/find/me</code>로 연결시켜준다. 물론 <code class=\"language-text\">false</code>면 요청 url 그대로 포워딩 해준다.</p>\n<p>또한 이러한 기능들을 추가로 커스터마이징 할 수 있어 자바 개발자는 정말 친숙하게 사용할 수가 있다.</p>\n<p>(<code class=\"language-text\">AWS</code>의 <code class=\"language-text\">API Gateway</code>가 좋은 점은 생략!)</p>\n<p>한가지 아쉬운 점은 현재 최신 버전 <code class=\"language-text\">spring-cloud-starter-netflix-zuul</code>을 쓰면 기본 <code class=\"language-text\">WAS</code>로 <code class=\"language-text\">Tomcat</code>을 사용하고 있다. 아무래도 <code class=\"language-text\">API Gateway</code>는 성능적으로 민감 할 수가 있어서 <code class=\"language-text\">Tomcat</code> 보다는 그래도 <code class=\"language-text\">Netty</code>(<code class=\"language-text\">undertow</code>)를 쓰는게 어떨까 싶다.</p>\n<p><code class=\"language-text\">Spring cloud Zuul</code>의 연관 모듈인 <code class=\"language-text\">zuul core</code>라는 녀석이 있는데 이게 <code class=\"language-text\">1.x</code> 버전에선 <code class=\"language-text\">Tomcat</code>을 쓰고, <code class=\"language-text\">2.x</code> 버전에선 <code class=\"language-text\">Undertow</code>를 쓰도록 바뀌어서 WAS를 <code class=\"language-text\">Undertow</code>로 바꾸고 싶으면 <code class=\"language-text\">zuul core</code> 버전을 바꾸던가 아니면 <code class=\"language-text\">Tomcat</code>을 제외 시키고 <code class=\"language-text\">Undertow</code>를 추가하던가 선택하면 된다.</p>\n<h2 id=\"22-eureka-discovery-server\" style=\"position:relative;\"><a href=\"#22-eureka-discovery-server\" aria-label=\"22 eureka discovery server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 Eureka (Discovery Server)</h2>\n<p>라이브 환경에선 어느정도 트래픽이 많으면 서버 이중화는 흔한 일이다. 단순 서버 인스턴스를 늘리고 해당 서버를 사용하는 다른 서버에 인스턴스 정보를 넘겨주고, 사용하는 쪽에서 적당히 라운드 로빈(로드벨런싱) 해주면 부하 분산을 위한 서버 다중화 작업은 끝나게 된다. 하지만 말은 쉽게 했지만 이러한 작업은 고려할께 많고 각 서버마다 인스턴스가 늘어가면서 모니터링 및 관리가 힘들어 질 수 밖에 없다. 이러한 귀찮은 작업을 Spring Cloud에서 <code class=\"language-text\">Discovery Server</code>역할을 담당하는 Eureka가 하게 된다. 유레카 서버를 올리고 다른 어플리케이션(<code class=\"language-text\">Eureka Client</code>가 된다)에 Eureka 정보를 넣어주면 어플리케이션이 실행 되면서 Eureka로 어플리케이션 정보 및 상태를 넘겨준다. 이런식으로 모인 각 어플리케이션의 인스턴스 정보를 필요한 어플리케이션에 각각 넣어주고(IP 정보 포함) 종료되면 다시 인스턴스 정보를 갱신한다(기본 적으로 30초 마다 인스턴스에 Ping을 날려 상태 점검도 한다).</p>\n<p>하지만 이번 공부하면서 유레카는 쓰지 않았다. 이유는 딱히 메리트를 못느껴서 그런데 유레카의 역할은 <code class=\"language-text\">Scale in/out</code>시 인스턴스의 정보, 상태를 모니터링 및 관리를 하는데 내가 <code class=\"language-text\">Spring Cloud</code>를 사용하게 된다면 최종적으로 <code class=\"language-text\">Docker</code> + <code class=\"language-text\">Spring Cloud</code> 조합으로 사용할 것이다.</p>\n<p>근데 Docker 생태계(<code class=\"language-text\">Docker Swarm</code>, <code class=\"language-text\">Kubernates</code>) 중엔 이러한 역할을 하는 얘들이 이미 있는데 구지 필요할까 의문이 들었고, 그렇다고 <code class=\"language-text\">Docker</code>를 포기하기엔 잃는게 더 많을꺼라 판단 하였다. <code class=\"language-text\">Docker Swarm</code>이나 <code class=\"language-text\">Kubernates</code>를 사용안하고 순수 <code class=\"language-text\">Docker</code>만 사용한다면 사용하는것도 괜찮을꺼 같긴하다(기술은 필요에 맞춰 도입하면 된다!).</p>\n<p>또한 <code class=\"language-text\">Eureka client</code>들, 그니까 다른 서버들은 Eureka 관련 Library에 종속성이 생기게 된다. 만약 다른 어플리케이션을 <code class=\"language-text\">Node.js</code>나 <code class=\"language-text\">Django</code>같은 걸로 만들었을 경우 <code class=\"language-text\">Eureka client</code>로 등록 하려면 외부 라이브러리를 사용해야 하지만 이러한 라이브러리를 제공해주지 않으면 어떻게 해야할지 감도 안잡힌다. 물론 방법이 있을 수도 있지만 그런거 하나하나 알아보는데 시간을 사용하니, 그냥 안쓰고 <code class=\"language-text\">Docker</code> 쓸꺼 같다.</p>\n<h2 id=\"23-ribbon-l7-load-balancing\" style=\"position:relative;\"><a href=\"#23-ribbon-l7-load-balancing\" aria-label=\"23 ribbon l7 load balancing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 Ribbon (L7 Load Balancing)</h2>\n<blockquote>\n<p><code class=\"language-text\">Load Balancer</code>는 대표적으로 2가지 종류가 있는데 <code class=\"language-text\">L4 Switch</code>, <code class=\"language-text\">L7 Switch</code> 2 종류가 있다. L4는 <code class=\"language-text\">OSI 7Layer</code>에서 L4 계층, 쉽게 말하면 네트워크 장비로 로드 벨런싱을 하는 것이고, L7은 <code class=\"language-text\">Application</code> 계층으로 로드 벨런싱을 하는 것을 말한다. <code class=\"language-text\">L4 Switch</code>는 가격이 엄청나게 비싸므로 돈없으면 사용하지도 못하거나 아니면 AWS의 <code class=\"language-text\">NLB</code>를 알아보면 되고, 여건이 안되면 결국에 사용해야 할 것은 <code class=\"language-text\">L7 Load Balancer</code> 이다</p>\n</blockquote>\n<p>우선 <code class=\"language-text\">Load Balancing</code>을 하고 싶으면 최소 2개 이상의 서버 인스턴스가 필요하고, 해당 인스턴스의 물리적 접근 주소(IP, Port 번호)를 <code class=\"language-text\">Load Balancer</code>에 제공해야 한다. 이때 <code class=\"language-text\">Eureka</code>와 궁합이 잘 맞는데 위에서 잠깐 설명 하였지만 Eureka는 필요한 곳에 물리적인 서버 목록을 제공해 준다.</p>\n<h4 id=\"ribbon\" style=\"position:relative;\"><a href=\"#ribbon\" aria-label=\"ribbon permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ribbon</h4>\n<p>Load balancing 관련 작업을 관리한다. <code class=\"language-text\">timeout</code>, <code class=\"language-text\">retry 정책</code>등을 설정 가능하고 필요한 서버 목록은 직접 물리적 주소를 적는 방법도 있으나, 그렇게 하면 탄력적으로 주소값을 확보 할 수 없으므로 <code class=\"language-text\">Eureka</code>한테 필요한 서버 목록 리스트를 요청하도록 셋팅도 가능하다.</p>\n<h4 id=\"eureka\" style=\"position:relative;\"><a href=\"#eureka\" aria-label=\"eureka permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Eureka</h4>\n<p>주기적으로 헬스 체크를 하여, 현재 활성화 된 서버 인스턴스 목록을 Ribbon에 제공해준다.</p>\n<h2 id=\"24-hystrix-circuit-breaker\" style=\"position:relative;\"><a href=\"#24-hystrix-circuit-breaker\" aria-label=\"24 hystrix circuit breaker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 Hystrix (Circuit Breaker)</h2>\n<ul>\n<li>\n<p>Circuit Breaker</p>\n<ul>\n<li>Open &#x26; Close</li>\n<li>fallback</li>\n</ul>\n</li>\n<li>\n<p>request 격리 방법</p>\n<ul>\n<li>Thread-Pool</li>\n<li>Semaphore</li>\n</ul>\n</li>\n</ul>\n<p>TODO</p>","fields":{"slug":"/posts/etc/etc-spring-cloud/","tagSlugs":["/tag/spring/","/tag/cloud/","/tag/msa/"]},"frontmatter":{"date":"2020-09-03T00:55:55.498Z","description":"MSA 환경에서 여러 어플리케이션을 효과적으로 개발 및 관리","tags":["spring","cloud","msa"],"title":"Spring Cloud - 기본 설명","socialImage":null}}},"pageContext":{"slug":"/posts/etc/etc-spring-cloud/"}}}